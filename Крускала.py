# # Алгоритм Кра(у)скала
# список ребер графа (длина, вершина 1, вершина 2)
# R = [(13, 1, 2), (18, 1, 3), (17, 1, 4), (14, 1, 5), (22, 1, 6),
#      (26, 2, 3), (22, 2, 5), (3, 3, 4), (19, 4, 6)]
R = [(15, 1, 2), (14, 1, 5), (23, 1, 4), (19, 2, 3), (16, 2, 4), (15, 2, 5), (14, 3, 5), (26, 3, 6), (25, 4, 5),
       (23, 4, 7), (20, 4, 8), (24, 5, 6), (27, 5, 8), (18, 5, 9), (14, 7, 8), (18, 8, 9)]
Rs = sorted(R, key=lambda x: x[0]) # сортировка по возрастанию по первому элементу списка R, т.е. по весам ребер
print(Rs)
U = set()   # список соединенных вершин
D = {}      # словарь списка изолированных групп вершин
T = []      # список ребер остова
cnt = 0
for r in Rs:
    if r[1] not in U or r[2] not in U:
        if r[1] not in U and r[2] not in U: # если обе вершины не соединены, то
            D[r[1]] = [r[1], r[2]]
            D[r[2]] = D[r[1]]
        else:
            if r[1] not in U:             # если в словаре нет первой вершины, то
                D[r[2]].append(r[1])
                D[r[1]] = D[r[2]]
            else:
                D[r[1]].append(r[2])        # иначе, все то же самое делаем со второй вершиной
                D[r[2]] = D[r[1]]

        T.append(r)   # добавляем ребро в остов
        cnt += r[0]
        U.add(r[1])             # добавляем вершины в множество U всех используемых вершин
        U.add(r[2])
for r in Rs:    # проходим по ребрам второй раз и объединяем разрозненные группы вершин
    if r[2] not in D[r[1]]:     # если вершины принадлежат разным группам, то объединяем, т.е. если между вершинами есть ребро, но ребра принадлежат разным группам, то объединить
        T.append(r)
        cnt += r[0]
        # добавляем ребро в остов
        gr1 = list(set(D[r[1]]))
        D[r[1]] += D[r[2]]# объединем списки двух групп вершин
        D[r[2]] += gr1
print(T)
print(cnt)